#!/usr/bin/env python3
#
# This Python/Tk script allows editing of data intended to be used by the
# Xilinx AXI Traffic Generator IP by generating .coe files from the input data.
#
# Copyright (C) 2018 Patricio Carr - pat@tuxengineering.com
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
import re
import pickle
from tkinter import *
from tkinter import messagebox
import atg_import

PROGRAM_NAME = 'AXI Traffic Generator'
MAX_ROWS = 255

class Application:
    def __init__(self, root):
        self.root = root
        self.root.title(PROGRAM_NAME)
        self.init_vars()
        self.createWidgets()
        self.root.grid()
        self.help_text = """
        Modes: In System Init mode, only write commands will be generated by the AXI Traffic Generator (ATG), so only the address and data columns are used and exported to .coe files.\nIn Test Mode, both reads and writes are generated by the ATG, so all four .coe files are exported. \n
        Please refer to Xilinx PG125 document for details.
        """

    def init_vars(self):
        self.axi_lite_type = IntVar()
        self.radix = 'hex'
        self.rows = [ \
                { \
                'check': 0, \
                'read_write': 0, \
                'ok_next_addr': 0, \
                'err_next_addr': 0, \
                'address': 0, \
                'data': 0, \
                'mask': 0, \
                'inc_error': 0, \
                'goto_ok': 0, \
                'goto_err': 0 \
                } \
                for k in range(MAX_ROWS)]

    def on_read_checkbox(self, var):
        def event_handler(event):
            self.process_checkbox(var)
        return event_handler

    def process_checkbox(self, idx):
        val = self.rows[idx]['read_write'].get()
        if val == False:
            mask_var = self.rows[idx]['mask']
            mask_var.set("blah")

    def createWidgets(self):
        type_frame = Frame(self.root, height=15, bd=5, relief=GROOVE, padx=5, pady=5)
        self.gentype = Radiobutton(type_frame, \
                text="System Init (only writes)", \
                variable=self.axi_lite_type, value=0).grid(sticky=W)
        self.gentype = Radiobutton(type_frame, \
                text="Test Mode (read and writes allowed)", \
                variable=self.axi_lite_type, value=1).grid(sticky=W)
        type_frame.grid(row=0, column=0)

        # Create a frame for the canvas and scrollbar(s).
        frame2 = Frame(self.root, bd=2, relief=FLAT)
        frame2.grid(row=3, column=0, sticky=NW)
        # Add a canvas in that frame.
        canvas = Canvas(frame2)
        canvas.grid(row=0, column=0)
        # Create a vertical scrollbar linked to the canvas.
        vsbar = Scrollbar(frame2, orient=VERTICAL, command=canvas.yview)
        vsbar.grid(row=0, column=1, sticky=NS)
        canvas.configure(yscrollcommand=vsbar.set)

        text_frame = Frame(canvas, bd=5, relief=GROOVE, padx=15, pady=15)
        Label(text_frame, text="Entry").grid(column=0,row=0)
        Label(text_frame, text="Address").grid(column=1,row=0)
        Label(text_frame, text="Data").grid(column=2,row=0)
        Label(text_frame, text="Write").grid(column=3,row=0)
        Label(text_frame, text="Read").grid(column=4,row=0)
        Label(text_frame, text="Mask").grid(column=5,row=0)
        Label(text_frame, text="Count?").grid(column=6,row=0)
        Label(text_frame, text="Goto Ok").grid(column=7,row=0)
        Label(text_frame, text="Goto Error").grid(column=8,row=0)

        for i in range(MAX_ROWS):
            Label(text_frame, text=i).grid(column=0,row=i+5)

            self.rows[i]['address'] = StringVar()
            addr = Entry(text_frame, \
                    textvariable=self.rows[i]['address'], \
                    width=10 \
                    ).grid(column=1,row=i+5)

            self.rows[i]['data'] = StringVar()
            data = Entry(text_frame,  \
                    textvariable=self.rows[i]['data'], \
                    width=10 \
                    ).grid(column=2,row=i+5)

            self.rows[i]['read_write'] = IntVar()
            self.rows[i]['read_write'].set(1)
            read = Radiobutton(text_frame, \
                    value=1, \
                    variable=self.rows[i]['read_write'] \
                    )
            #read.bind('<Button-1>', self.on_read_checkbox(i))  # TODO
            read.grid(column=3,row=i+5)

            read = Radiobutton(text_frame, \
                    value=0, \
                    variable=self.rows[i]['read_write'] \
                    )
            read.grid(column=4,row=i+5)

            self.rows[i]['mask'] = StringVar()
            data = Entry(text_frame,  \
                    textvariable=self.rows[i]['mask'], \
                    width=10 \
                    ).grid(column=5,row=i+5)

            self.rows[i]['inc_error'] = BooleanVar()
            self.rows[i]['inc_error'].set(True)
            data = Checkbutton(text_frame,  \
                    variable=self.rows[i]['inc_error'] \
                    ).grid(column=6,row=i+5)

            self.rows[i]['goto_ok'] = IntVar()
            self.rows[i]['goto_ok'].set(i+1)
            data = Entry(text_frame,  \
                    textvariable=self.rows[i]['goto_ok'], \
                    width=4, \
                    ).grid(column=7,row=i+5)

            self.rows[i]['goto_err'] = IntVar()
            self.rows[i]['goto_err'].set(i)
            data = Entry(text_frame,  \
                    textvariable=self.rows[i]['goto_err'], \
                    width=4, \
                    ).grid(column=8,row=i+5)

        self.rows[MAX_ROWS-1]['address'].set('FFFFFFFF')
        text_frame.grid(row=6, columnspan=5)

        # Create canvas window to hold the buttons_frame.
        canvas.create_window((0,0), window=text_frame, anchor=NW)
        text_frame.update_idletasks()  # Needed to make bbox info available.
        bbox = canvas.bbox(ALL)  # Get bounding box of canvas with Buttons.
        # Define the scrollable region as entire canvas with only the desired
        # number of rows and columns displayed.
        w, h = bbox[2]-bbox[1], bbox[3]-bbox[1]
        canvas.configure(scrollregion=bbox, width=w, height=255)

        buttons_frame = Frame(self.root, bd=5, relief=GROOVE, padx=5, pady=5)
        self.quitButton = Button(buttons_frame, text='Quit', command=quit)
        self.quitButton.grid(row=0, column=0, padx=20)
        self.loadButton = Button(buttons_frame, text='Load', command=self.loadFile)
        self.loadButton.grid(row=0, column=1, padx=20)
        self.saveButton = Button(buttons_frame, text='Save', command=self.saveFile)
        self.saveButton.grid(row=0, column=2, padx=20)
        self.dumpButton = Button(buttons_frame, text='Export', command=self.exportCoe)
        self.dumpButton.grid(row=0, column=3, padx=20)
        self.readButton = Button(buttons_frame, text='Import...', command=self.import_dialog)
        self.readButton.grid(row=0, column=4, padx=20)
        self.helpButton = Button(buttons_frame, text='Help', command=self.help_dialog)
        self.helpButton.grid(row=0, column=5, padx=20)
        buttons_frame.grid()

    def to_hex(self, string):
        if string == '':
            string = '0'
        try:
            int_val = int(string,16)
        except:
            print ("There was a problem translating a string to hex")
            int_val = 0
        hex_str = "{0:08x}".format(int_val)
        return hex_str

    def readCoe(self, filename):
        """ Read from file into array. Get radix from file and parse vectors accordingly.
        """
        array=[]
        radix_re = re.compile(r'\d+')
        with open(filename, 'r') as f:
            for line in iter(f.readline, ''):
                if 'radix' in line:                    # Find radix literal and
                    radix = radix_re.findall(line)[0]  # Extract from returned list
                    if radix == '16':
                        self.radix = 'hex'
                    elif radix == '2':
                        self.radix = 'bin'
                    else: #radix == '10':
                        self.radix = 'dec'
                    continue
                if 'memory' in line:
                    continue
                if ';' in line[0]:         # Ignore lines with only ';'
                    continue
                if line.isspace():
                    continue
                vec = line.replace(";", "").strip()     # Remove any ';' chars
                vec = vec.replace(",", "").strip()      # Remove any ',' chars
                if self.radix == 'hex':
                    pass
                elif self.radix == 'bin':
                    vec = '{0:08x}'.format(int(vec, 2))
                elif self.radix == 'dec':
                    vec = '{0:08x}'.format(int(vec, 10))
                array.append(vec)
        return array

    def writeCoe(self, filetype, array):
        """ Write <filetype>.coe file from array content """
        with open(filetype+'.coe', 'wb') as f:
            f.write('memory_initialization_radix = 16;\n'.encode())
            f.write('memory_initialization_vector =\n'.encode())
            for row in array:
                f.write(row.encode())
                f.write('\n'.encode())
            f.write(';\n'.encode())

    def row_to_ctrl(self, row):
        """ Merge fields into control word """
        ctrl = (row['goto_ok'].get() << 8) + row['goto_err'].get()
        if row['read_write'].get() == 1:
            ctrl = ctrl + (1 << 16)
        if row['inc_error'].get() == True:
            ctrl = ctrl + (1 << 17)
        ret = "{0:08x}".format(ctrl)
        return ret

    def ctrl_to_row(self, string):
        """ Parse control string into fields dict """
        val = int(string, 16)
        row = {}
        row['goto_err'] = val & 0xFF
        row['goto_ok'] = (val >> 8) & 0xFF
        row['read_write'] = (val & 0x10000) >> 16
        row['inc_error'] = ((val & 0x20000) >> 17 == 1)
        return row

    def exportCoe(self):
        addr_db = []
        data_db = []
        mask_db = []
        ctrl_db = []
        for i, row in enumerate(self.rows):
            addr_db.append(self.to_hex(row['address'].get()))
            data_db.append(self.to_hex(row['data'].get()))
            mask_db.append(self.to_hex(row['mask'].get()))
            ctrl_db.append(self.row_to_ctrl(row))

        self.writeCoe('addr', addr_db)
        self.writeCoe('data', data_db)
        if self.axi_lite_type.get() > 0:
            self.writeCoe('mask', mask_db)
            self.writeCoe('ctrl', ctrl_db)

    def saveFile(self):
        sav = []
        sav.append(self.axi_lite_type.get())
        for i in range(MAX_ROWS):
            sav.append({ \
                    'address'   : self.rows[i]['address'].get(), \
                    'data'      : self.rows[i]['data'].get(), \
                    'read_write': self.rows[i]['read_write'].get(), \
                    'mask'      : self.rows[i]['mask'].get(), \
                    'inc_error' : self.rows[i]['inc_error'].get(), \
                    'goto_ok'   : self.rows[i]['goto_ok'].get(), \
                    'goto_err'  : self.rows[i]['goto_err'].get() \
                    } \
                    )
            with open('data.atg', 'wb') as f:
                pickle.dump(sav, f)

    def loadFile(self):
        load_ok = False
        sav = []
        with open('data.atg', 'rb') as f:
            sav = pickle.load(f)
            load_ok = True
        if load_ok:
            self.axi_lite_type.set(sav[0])
            sav.pop(0)
            for i in range(MAX_ROWS):
                self.rows[i]['address'].set(sav[i]['address'])
                self.rows[i]['data'].set(sav[i]['data'])
                self.rows[i]['read_write'].set(sav[i]['read_write'])
                self.rows[i]['mask'].set(sav[i]['mask'])
                self.rows[i]['inc_error'].set(sav[i]['inc_error'])
                self.rows[i]['goto_ok'].set(sav[i]['goto_ok'])
                self.rows[i]['goto_err'].set(sav[i]['goto_err'])

    def help_dialog(self):
        messagebox.showinfo("Help", self.help_text)

    def import_dialog(self):
        dialog = atg_import.ATG_Import(self.root, 'File import')
        if not dialog.result:
            return
        column=dialog.result['column']
        filename=dialog.result['filename']
        array = self.readCoe(filename)
        i=0
        for item in array:
            if i >= MAX_ROWS:
                break
            if column == 'control':         # Special handling for Control file
                row = self.ctrl_to_row(item)
                self.rows[i]['goto_ok'].set(row['goto_ok'])
                self.rows[i]['goto_err'].set(row['goto_err'])
                self.rows[i]['inc_error'].set(row['inc_error'])
                self.rows[i]['read_write'].set(row['read_write'])
            else:
                self.rows[i][column].set(item)
            i=i+1

if __name__ == '__main__':
    root = Tk()
    Application(root)
    root.mainloop()

